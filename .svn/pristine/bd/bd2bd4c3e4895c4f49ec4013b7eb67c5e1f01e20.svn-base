var biRadixBase = 2; var biRadixBits = 16; var bitsPerDigit = biRadixBits; var biRadix = 1 << 16; var biHalfRadix = biRadix >>> 1; var biRadixSquared = biRadix * biRadix; var maxDigitVal = biRadix - 1; var maxInteger = 9999999999999998; var maxDigits; var ZERO_ARRAY; var bigZero, bigOne; function setMaxDigits(a) { maxDigits = a; ZERO_ARRAY = new Array(maxDigits); for (var b = 0; b < ZERO_ARRAY.length; b++) ZERO_ARRAY[b] = 0; bigZero = new BigInt(); bigOne = new BigInt(); bigOne.digits[0] = 1 } setMaxDigits(20); var dpl10 = 15; var lr10 = biFromNumber(1000000000000000); function BigInt(a) { if (typeof a == "boolean" && a == true) { this.digits = null } else { this.digits = ZERO_ARRAY.slice(0) } this.isNeg = false } function biFromDecimal(s) { var a = s.charAt(0) == '-'; var i = a ? 1 : 0; var b; while (i < s.length && s.charAt(i) == '0')++i; if (i == s.length) { b = new BigInt() } else { var c = s.length - i; var d = c % dpl10; if (d == 0) d = dpl10; b = biFromNumber(Number(s.substr(i, d))); i += d; while (i < s.length) { b = biAdd(biMultiply(b, lr10), biFromNumber(Number(s.substr(i, dpl10)))); i += dpl10 } b.isNeg = a } return b } function biCopy(a) { var b = new BigInt(true); b.digits = a.digits.slice(0); b.isNeg = a.isNeg; return b } function biFromNumber(i) { var a = new BigInt(); a.isNeg = i < 0; i = Math.abs(i); var j = 0; while (i > 0) { a.digits[j++] = i & maxDigitVal; i >>= biRadixBits } return a } function reverseStr(s) { var a = ""; for (var i = s.length - 1; i > -1; --i) { a += s.charAt(i) } return a } var hexatrigesimalToChar = new Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'); function biToString(x, a) { var b = new BigInt(); b.digits[0] = a; var c = biDivideModulo(x, b); var d = hexatrigesimalToChar[c[1].digits[0]]; while (biCompare(c[0], bigZero) == 1) { c = biDivideModulo(c[0], b); digit = c[1].digits[0]; d += hexatrigesimalToChar[c[1].digits[0]] } return (x.isNeg ? "-" : "") + reverseStr(d) } function biToDecimal(x) { var b = new BigInt(); b.digits[0] = 10; var a = biDivideModulo(x, b); var c = String(a[1].digits[0]); while (biCompare(a[0], bigZero) == 1) { a = biDivideModulo(a[0], b); c += String(a[1].digits[0]) } return (x.isNeg ? "-" : "") + reverseStr(c) } var hexToChar = new Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'); function digitToHex(n) { var a = 0xf; var b = ""; for (i = 0; i < 4; ++i) { b += hexToChar[n & a]; n >>>= 4 } return reverseStr(b) } function biToHex(x) { var a = ""; var n = biHighIndex(x); for (var i = biHighIndex(x) ; i > -1; --i) { a += digitToHex(x.digits[i]) } return a } function charToHex(c) { var a = 48; var b = a + 9; var d = 97; var e = d + 25; var f = 65; var g = 65 + 25; var h; if (c >= a && c <= b) { h = c - a } else if (c >= f && c <= g) { h = 10 + c - f } else if (c >= d && c <= e) { h = 10 + c - d } else { h = 0 } return h } function hexToDigit(s) { var a = 0; var b = Math.min(s.length, 4); for (var i = 0; i < b; ++i) { a <<= 4; a |= charToHex(s.charCodeAt(i)) } return a } function biFromHex(s) { var a = new BigInt(); var b = s.length; for (var i = b, j = 0; i > 0; i -= 4, ++j) { a.digits[j] = hexToDigit(s.substr(Math.max(i - 4, 0), Math.min(i, 4))) } return a } function biFromString(s, a) { var b = s.charAt(0) == '-'; var d = b ? 1 : 0; var e = new BigInt(); var f = new BigInt(); f.digits[0] = 1; for (var i = s.length - 1; i >= d; i--) { var c = s.charCodeAt(i); var g = charToHex(c); var h = biMultiplyDigit(f, g); e = biAdd(e, h); f = biMultiplyDigit(f, a) } e.isNeg = b; return e } function biDump(b) { return (b.isNeg ? "-" : "") + b.digits.join(" ") } function biAdd(x, y) { var a; if (x.isNeg != y.isNeg) { y.isNeg = !y.isNeg; a = biSubtract(x, y); y.isNeg = !y.isNeg } else { a = new BigInt(); var c = 0; var n; for (var i = 0; i < x.digits.length; ++i) { n = x.digits[i] + y.digits[i] + c; a.digits[i] = n & 0xffff; c = Number(n >= biRadix) } a.isNeg = x.isNeg } return a } function biSubtract(x, y) { var a; if (x.isNeg != y.isNeg) { y.isNeg = !y.isNeg; a = biAdd(x, y); y.isNeg = !y.isNeg } else { a = new BigInt(); var n, c; c = 0; for (var i = 0; i < x.digits.length; ++i) { n = x.digits[i] - y.digits[i] + c; a.digits[i] = n & 0xffff; if (a.digits[i] < 0) a.digits[i] += biRadix; c = 0 - Number(n < 0) } if (c == -1) { c = 0; for (var i = 0; i < x.digits.length; ++i) { n = 0 - a.digits[i] + c; a.digits[i] = n & 0xffff; if (a.digits[i] < 0) a.digits[i] += biRadix; c = 0 - Number(n < 0) } a.isNeg = !x.isNeg } else { a.isNeg = x.isNeg } } return a } function biHighIndex(x) { var a = x.digits.length - 1; while (a > 0 && x.digits[a] == 0)--a; return a } function biNumBits(x) { var n = biHighIndex(x); var d = x.digits[n]; var m = (n + 1) * bitsPerDigit; var a; for (a = m; a > m - bitsPerDigit; --a) { if ((d & 0x8000) != 0) break; d <<= 1 } return a } function biMultiply(x, y) { var a = new BigInt(); var c; var n = biHighIndex(x); var t = biHighIndex(y); var u, uv, k; for (var i = 0; i <= t; ++i) { c = 0; k = i; for (j = 0; j <= n; ++j, ++k) { uv = a.digits[k] + x.digits[j] * y.digits[i] + c; a.digits[k] = uv & maxDigitVal; c = uv >>> biRadixBits } a.digits[i + n + 1] = c } a.isNeg = x.isNeg != y.isNeg; return a } function biMultiplyDigit(x, y) { var n, c, uv; result = new BigInt(); n = biHighIndex(x); c = 0; for (var j = 0; j <= n; ++j) { uv = result.digits[j] + x.digits[j] * y + c; result.digits[j] = uv & maxDigitVal; c = uv >>> biRadixBits } result.digits[1 + n] = c; return result } function arrayCopy(a, b, c, d, n) { var m = Math.min(b + n, a.length); for (var i = b, j = d; i < m; ++i, ++j) { c[j] = a[i] } } var highBitMasks = new Array(0x0000, 0x8000, 0xC000, 0xE000, 0xF000, 0xF800, 0xFC00, 0xFE00, 0xFF00, 0xFF80, 0xFFC0, 0xFFE0, 0xFFF0, 0xFFF8, 0xFFFC, 0xFFFE, 0xFFFF); function biShiftLeft(x, n) { var a = Math.floor(n / bitsPerDigit); var b = new BigInt(); arrayCopy(x.digits, 0, b.digits, a, b.digits.length - a); var c = n % bitsPerDigit; var d = bitsPerDigit - c; for (var i = b.digits.length - 1, i1 = i - 1; i > 0; --i, --i1) { b.digits[i] = ((b.digits[i] << c) & maxDigitVal) | ((b.digits[i1] & highBitMasks[c]) >>> (d)) } b.digits[0] = ((b.digits[i] << c) & maxDigitVal); b.isNeg = x.isNeg; return b } var lowBitMasks = new Array(0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF); function biShiftRight(x, n) { var a = Math.floor(n / bitsPerDigit); var b = new BigInt(); arrayCopy(x.digits, a, b.digits, 0, x.digits.length - a); var c = n % bitsPerDigit; var d = bitsPerDigit - c; for (var i = 0, i1 = i + 1; i < b.digits.length - 1; ++i, ++i1) { b.digits[i] = (b.digits[i] >>> c) | ((b.digits[i1] & lowBitMasks[c]) << d) } b.digits[b.digits.length - 1] >>>= c; b.isNeg = x.isNeg; return b } function biMultiplyByRadixPower(x, n) { var a = new BigInt(); arrayCopy(x.digits, 0, a.digits, n, a.digits.length - n); return a } function biDivideByRadixPower(x, n) { var a = new BigInt(); arrayCopy(x.digits, n, a.digits, 0, a.digits.length - n); return a } function biModuloByRadixPower(x, n) { var a = new BigInt(); arrayCopy(x.digits, 0, a.digits, 0, n); return a } function biCompare(x, y) { if (x.isNeg != y.isNeg) { return 1 - 2 * Number(x.isNeg) } for (var i = x.digits.length - 1; i >= 0; --i) { if (x.digits[i] != y.digits[i]) { if (x.isNeg) { return 1 - 2 * Number(x.digits[i] > y.digits[i]) } else { return 1 - 2 * Number(x.digits[i] < y.digits[i]) } } } return 0 } function biDivideModulo(x, y) { var a = biNumBits(x); var c = biNumBits(y); var d = y.isNeg; var q, r; if (a < c) { if (x.isNeg) { q = biCopy(bigOne); q.isNeg = !y.isNeg; x.isNeg = false; y.isNeg = false; r = biSubtract(y, x); x.isNeg = true; y.isNeg = d } else { q = new BigInt(); r = biCopy(x) } return new Array(q, r) } q = new BigInt(); r = x; var t = Math.ceil(c / bitsPerDigit) - 1; var e = 0; while (y.digits[t] < biHalfRadix) { y = biShiftLeft(y, 1); ++e; ++c; t = Math.ceil(c / bitsPerDigit) - 1 } r = biShiftLeft(r, e); a += e; var n = Math.ceil(a / bitsPerDigit) - 1; var b = biMultiplyByRadixPower(y, n - t); while (biCompare(r, b) != -1) { ++q.digits[n - t]; r = biSubtract(r, b) } for (var i = n; i > t; --i) { var f = (i >= r.digits.length) ? 0 : r.digits[i]; var g = (i - 1 >= r.digits.length) ? 0 : r.digits[i - 1]; var h = (i - 2 >= r.digits.length) ? 0 : r.digits[i - 2]; var j = (t >= y.digits.length) ? 0 : y.digits[t]; var k = (t - 1 >= y.digits.length) ? 0 : y.digits[t - 1]; if (f == j) { q.digits[i - t - 1] = maxDigitVal } else { q.digits[i - t - 1] = Math.floor((f * biRadix + g) / j) } var l = q.digits[i - t - 1] * ((j * biRadix) + k); var m = (f * biRadixSquared) + ((g * biRadix) + h); while (l > m) { --q.digits[i - t - 1]; l = q.digits[i - t - 1] * ((j * biRadix) | k); m = (f * biRadix * biRadix) + ((g * biRadix) + h) } b = biMultiplyByRadixPower(y, i - t - 1); r = biSubtract(r, biMultiplyDigit(b, q.digits[i - t - 1])); if (r.isNeg) { r = biAdd(r, b); --q.digits[i - t - 1] } } r = biShiftRight(r, e); q.isNeg = x.isNeg != d; if (x.isNeg) { if (d) { q = biAdd(q, bigOne) } else { q = biSubtract(q, bigOne) } y = biShiftRight(y, e); r = biSubtract(y, r) } if (r.digits[0] == 0 && biHighIndex(r) == 0) r.isNeg = false; return new Array(q, r) } function biDivide(x, y) { return biDivideModulo(x, y)[0] } function biModulo(x, y) { return biDivideModulo(x, y)[1] } function biMultiplyMod(x, y, m) { return biModulo(biMultiply(x, y), m) } function biPow(x, y) { var b = bigOne; var a = x; while (true) { if ((y & 1) != 0) b = biMultiply(b, a); y >>= 1; if (y == 0) break; a = biMultiply(a, a) } return b } function biPowMod(x, y, m) { var b = bigOne; var a = x; var k = y; while (true) { if ((k.digits[0] & 1) != 0) b = biMultiplyMod(b, a, m); k = biShiftRight(k, 1); if (k.digits[0] == 0 && biHighIndex(k) == 0) break; a = biMultiplyMod(a, a, m) } return b }